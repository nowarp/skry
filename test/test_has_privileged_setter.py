"""
Test HasPrivilegedSetter fact generation for mutable config fields.

This tests that setter functions with capability parameters are correctly
identified as privileged setters for config fields.
"""

from core.context import ProjectContext
from analysis.access_control import generate_checks_role_facts
from analysis.derived_facts import generate_has_privileged_setter_facts
from core.facts import Fact


def test_has_privileged_setter_with_capability_param():
    """Test that setter with capability parameter generates HasPrivilegedSetter fact."""

    # Create minimal context with manual facts
    ctx = ProjectContext(["test.move"])
    file_ctx = ctx.source_files["test.move"]
    file_ctx.module_path = "test::config"

    # Manually create facts that would be generated by parser and analyzers
    file_ctx.facts = [
        # Struct and role definitions
        Fact("Struct", ("test::config::AdminCap",)),
        Fact("IsCapability", ("test::config::AdminCap",)),
        Fact("IsPrivileged", ("test::config::AdminCap",)),

        Fact("Struct", ("test::config::Config",)),
        Fact("StructField", ("test::config::Config", 0, "fee_rate", "u64")),

        # Setter function with capability parameter
        Fact("Fun", ("test::config::set_fee_rate",)),
        Fact("FormalArg", ("test::config::set_fee_rate", 0, "_admin", "&AdminCap")),
        Fact("FormalArg", ("test::config::set_fee_rate", 1, "config", "&mut Config")),

        # WritesField fact (would be generated by IR analysis)
        Fact("WritesField", ("test::config::set_fee_rate", "test::config::Config", "fee_rate")),
    ]

    # Generate ChecksCapability facts
    generate_checks_role_facts(ctx)

    # Verify ChecksCapability was generated
    checks_role_facts = [f for f in file_ctx.facts if f.name == "ChecksCapability"]
    assert len(checks_role_facts) > 0, "ChecksCapability fact should be generated"

    # Generate HasPrivilegedSetter facts
    count = generate_has_privileged_setter_facts(ctx)

    # Collect HasPrivilegedSetter facts
    setter_facts = [f for f in file_ctx.facts if f.name == "HasPrivilegedSetter"]

    assert len(setter_facts) > 0, \
        f"HasPrivilegedSetter fact should be generated for Config.fee_rate. Got facts: {setter_facts}"

    assert setter_facts[0].args == ("test::config::Config", "fee_rate"), \
        f"HasPrivilegedSetter should be for Config.fee_rate, got: {setter_facts[0].args}"

    print(f"✓ Generated {count} HasPrivilegedSetter facts")
    print("✓ Setter with capability parameter correctly identified as privileged setter")


def test_has_privileged_setter_without_role_not_generated():
    """Test that setter WITHOUT capability parameter does NOT generate HasPrivilegedSetter fact."""

    ctx = ProjectContext(["test.move"])
    file_ctx = ctx.source_files["test.move"]
    file_ctx.module_path = "test::config"

    # Setter without capability parameter
    file_ctx.facts = [
        Fact("Struct", ("test::config::Config",)),
        Fact("StructField", ("test::config::Config", 0, "fee_rate", "u64")),

        # Unprotected setter function (no capability param)
        Fact("Fun", ("test::config::set_fee_rate",)),
        Fact("FormalArg", ("test::config::set_fee_rate", 0, "config", "&mut Config")),

        # WritesField fact
        Fact("WritesField", ("test::config::set_fee_rate", "test::config::Config", "fee_rate")),
    ]

    # Generate ChecksCapability and HasPrivilegedSetter facts
    generate_checks_role_facts(ctx)
    generate_has_privileged_setter_facts(ctx)

    # Should NOT generate HasPrivilegedSetter
    setter_facts = [f for f in file_ctx.facts if f.name == "HasPrivilegedSetter"]

    assert len(setter_facts) == 0, \
        f"HasPrivilegedSetter should NOT be generated for unprotected setter. Got: {setter_facts}"

    print("✓ Unprotected setter correctly does NOT generate HasPrivilegedSetter fact")


def test_init_function_not_counted_as_setter():
    """Test that init function writes are NOT counted as privileged setters."""

    ctx = ProjectContext(["test.move"])
    file_ctx = ctx.source_files["test.move"]
    file_ctx.module_path = "test::config"

    file_ctx.facts = [
        Fact("Struct", ("test::config::AdminCap",)),
        Fact("IsCapability", ("test::config::AdminCap",)),
        Fact("IsPrivileged", ("test::config::AdminCap",)),

        Fact("Struct", ("test::config::Config",)),
        Fact("StructField", ("test::config::Config", 0, "fee_rate", "u64")),

        # Init function
        Fact("Fun", ("test::config::init",)),
        Fact("IsInit", ("test::config::init",)),
        Fact("FormalArg", ("test::config::init", 0, "ctx", "&mut TxContext")),

        # Init writes to field (initial value)
        Fact("WritesField", ("test::config::init", "test::config::Config", "fee_rate")),
    ]

    # Generate facts
    generate_checks_role_facts(ctx)
    generate_has_privileged_setter_facts(ctx)

    # Init should NOT count as privileged setter
    setter_facts = [f for f in file_ctx.facts if f.name == "HasPrivilegedSetter"]

    assert len(setter_facts) == 0, \
        f"Init function should NOT generate HasPrivilegedSetter fact. Got: {setter_facts}"

    print("✓ Init function correctly excluded from HasPrivilegedSetter generation")


if __name__ == "__main__":
    test_has_privileged_setter_with_capability_param()
    test_has_privileged_setter_without_role_not_generated()
    test_init_function_not_counted_as_setter()
